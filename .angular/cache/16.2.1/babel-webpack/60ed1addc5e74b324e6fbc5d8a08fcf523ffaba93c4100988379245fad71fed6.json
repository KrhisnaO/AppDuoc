{"ast":null,"code":"import _asyncToGenerator from \"/Users/krhisnaoyanedelyanez/Desktop/ProyectosIonic/AppDuoc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { __decorate } from \"tslib\";\nimport { Component, ElementRef, ViewChild } from '@angular/core';\nimport { Usuario } from 'src/app/model/Usuario';\nimport { Asistencia } from 'src/app/model/asistencia';\nimport jsQR from 'jsqr';\nlet HomePage = class HomePage {\n  constructor(activeroute // Permite obtener los parámetros de la página login\n  , router // Permite navegar entre páginas\n  , alertController // Permite mostrar mensajes emergentes más complejos que Toast\n  , animationController) {\n    this.activeroute = activeroute;\n    this.router = router;\n    this.alertController = alertController;\n    this.animationController = animationController;\n    this.asistencia = new Asistencia();\n    this.escaneando = false;\n    this.datosQR = '';\n    this.usuario = new Usuario('', '', '', '', '', '');\n    // Se llama a la ruta activa y se obtienen sus parámetros mediante una subscripcion\n    this.activeroute.queryParams.subscribe(params => {\n      const nav = this.router.getCurrentNavigation();\n      if (nav) {\n        // Si tiene datos extra, se rescatan y se asignan a una propiedad\n        if (nav.extras.state) {\n          this.usuario = nav.extras.state['usuario'];\n          return;\n        }\n      }\n      // Si no vienen datos extra desde la página anterior, quiere decir que el usuario\n      // intentó entrar directamente a la página home sin pasar por el login,\n      // de modo que el sistema debe enviarlo al login para que inicie sesión.\n      this.router.navigate(['/login']);\n    });\n  }\n  animateItem(elementRef) {\n    this.animationController.create().addElement(elementRef).iterations(1).duration(600).fromTo('transform', 'translate(100%)', 'translate(0%)').play();\n  }\n  ngOnInit() {}\n  ngAfterViewInit() {\n    if (this.itemTitulo) {\n      const animation = this.animationController.create().addElement(this.itemTitulo.nativeElement).iterations(1).duration(3000).fromTo('transform', 'translate(0%)', 'translate(45%)').fromTo('opacity', 0.2, 1);\n      animation.play();\n    }\n  }\n  // Se va a solicitar el uso de la cámara, por medio de \"navigator.mediaDevices.getUserMedia\".\n  // La cámara es necesaria para poder capturar el Código QR.\n  // Luego se cofigurará:\n  //     this.video.nativeElement.setAttribute('playsinline', 'true');\n  // que permite que el video se reproduzca dentro del contexto de la página, en lugar de\n  // cambiar automáticamente al modo de pantalla completa en dispositivos iOS. \n  // Esto sirve para proporcionar una experiencia de usuario más fluida y evitar \n  // interrupciones al reproducir videos en el sitio web. Luego se iniciará el proceso de\n  // escaneo indicándolo por medio de la variable \"this.escaneando = true;\" y se podrá detener \n  // el escaneo por medio del botón de \"Detener\" que cambia a \"this.escaneando = false;\" o bien\n  // si la cámara detecta un código QR.\n  comenzarEscaneoQR() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const mediaProvider = yield navigator.mediaDevices.getUserMedia({\n        video: {\n          facingMode: 'environment'\n        }\n      });\n      _this.video.nativeElement.srcObject = mediaProvider;\n      _this.video.nativeElement.setAttribute('playsinline', 'true');\n      _this.video.nativeElement.play();\n      _this.escaneando = true;\n      requestAnimationFrame(_this.verificarVideo.bind(_this));\n    })();\n  }\n  // Las imágenes de la cámara se analizan muchas veces, hasta que logre encontrar un Código QR,\n  // por esta razón se usa la función del navegador \"requestAnimationFrame\", que permite realizar\n  // actualizaciones de la interfaz de usuario de manera eficiente y sincronizada con los \n  // refrescos de la pantalla. Entonces, en cada refresco de pantalla el programa realizará una\n  // pequeña pausa para analizar si el fotograma capturado es o no un Código QR, por medio de\n  // la función this.obtenerDatosQR().\n  verificarVideo() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.video.nativeElement.readyState === _this2.video.nativeElement.HAVE_ENOUGH_DATA) {\n        if (_this2.obtenerDatosQR() || !_this2.escaneando) return;\n        requestAnimationFrame(_this2.verificarVideo.bind(_this2));\n      } else {\n        requestAnimationFrame(_this2.verificarVideo.bind(_this2));\n      }\n    })();\n  }\n  // Si \"obtenerDatosQR\" encuentra un QR válido entonces se mostrarán los datos en pantalla\n  // y se devolverá true para detener el escaneo. En caso contrario, mientras no se detecte\n  // un QR, la función \"obtenerDatosQR\" devolverá false y el método \"verificarVideo\" se \n  // volverá a ejecutar nuevamente.\n  // Para analizar la imagen se usan los Elementos HTML: video y canvas. El TAG HTML \"video\"\n  // sirve para establecer un recuadro en la pantalla donde se visualiza el video de la \n  // cámara. Cada fotograma de la cámara es redibujado dentro del TAG HTML \"canvas\", \n  // de modo que es la imagen del canvas, la que analiza la biblioteca \"jsQR\". \n  obtenerDatosQR() {\n    const w = this.video.nativeElement.videoWidth;\n    const h = this.video.nativeElement.videoHeight;\n    this.canvas.nativeElement.width = w;\n    this.canvas.nativeElement.height = h;\n    const context = this.canvas.nativeElement.getContext('2d');\n    context.drawImage(this.video.nativeElement, 0, 0, w, h);\n    const img = context.getImageData(0, 0, w, h);\n    let qrCode = jsQR(img.data, w, h, {\n      inversionAttempts: 'dontInvert'\n    });\n    if (qrCode) {\n      if (qrCode.data !== '') {\n        this.escaneando = false;\n        this.mostrarDatosQROrdenados(qrCode.data);\n        return true;\n      }\n    }\n    return false;\n  }\n  mostrarDatosQROrdenados(datosQR) {\n    this.datosQR = datosQR;\n    const objetoDatosQR = JSON.parse(datosQR);\n    // ----------------------------------\n    // TAREA PARA COMPLETAR POR EL ALUMNO\n    // ----------------------------------\n    // 1) Ejecutar el setter de la clase Asistencia:\n    //     this.asistencia.setAsistencia(...parametros...)\n    //    de modo que los parámetros los tome del objeto datosQR,\n    //    por ejemplo: datosQR.nombreAsignatura contiene el valor \n    //    del nombre de la asignatura en la cual el alumno\n    //    debe quedar presente.\n    // 2) Hacer una interpolación entre las propiedades \n    //    de \"this.asistencia\" y la página HTML, de modo\n    //    que la página muestre de manera ordenada estos datos.\n  }\n  // Si la propiedad this.escaneando cambia a false, entonces la función\n  // \"verificarVideo\" deja de ejecutarse y se detiene el escaneo del QR.\n  detenerEscaneoQR() {\n    this.escaneando = false;\n  }\n};\n__decorate([ViewChild('titulo', {\n  read: ElementRef\n})], HomePage.prototype, \"itemTitulo\", void 0);\n__decorate([ViewChild('video')], HomePage.prototype, \"video\", void 0);\n__decorate([ViewChild('canvas')], HomePage.prototype, \"canvas\", void 0);\nHomePage = __decorate([Component({\n  selector: 'app-home',\n  templateUrl: './home.page.html',\n  styleUrls: ['./home.page.scss']\n})], HomePage);\nexport { HomePage };","map":{"version":3,"names":["Component","ElementRef","ViewChild","Usuario","Asistencia","jsQR","HomePage","constructor","activeroute","router","alertController","animationController","asistencia","escaneando","datosQR","usuario","queryParams","subscribe","params","nav","getCurrentNavigation","extras","state","navigate","animateItem","elementRef","create","addElement","iterations","duration","fromTo","play","ngOnInit","ngAfterViewInit","itemTitulo","animation","nativeElement","comenzarEscaneoQR","_this","_asyncToGenerator","mediaProvider","navigator","mediaDevices","getUserMedia","video","facingMode","srcObject","setAttribute","requestAnimationFrame","verificarVideo","bind","_this2","readyState","HAVE_ENOUGH_DATA","obtenerDatosQR","w","videoWidth","h","videoHeight","canvas","width","height","context","getContext","drawImage","img","getImageData","qrCode","data","inversionAttempts","mostrarDatosQROrdenados","objetoDatosQR","JSON","parse","detenerEscaneoQR","__decorate","read","selector","templateUrl","styleUrls"],"sources":["/Users/krhisnaoyanedelyanez/Desktop/ProyectosIonic/AppDuoc/src/app/pages/home/home.page.ts"],"sourcesContent":["import { AfterViewInit, Component, ElementRef, OnInit, ViewChild } from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { AlertController } from '@ionic/angular';\nimport { AnimationController} from '@ionic/angular';\nimport { Usuario } from 'src/app/model/Usuario';\nimport { Asistencia } from 'src/app/model/asistencia';\nimport jsQR, { QRCode } from 'jsqr';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: './home.page.html',\n  styleUrls: ['./home.page.scss'],\n})\nexport class HomePage implements OnInit, AfterViewInit {\n\n  @ViewChild('titulo', { read: ElementRef }) itemTitulo!: ElementRef;\n    @ViewChild('video')\n  private video!: ElementRef;\n\n  @ViewChild('canvas')\n  private canvas!: ElementRef;\n\n  public asistencia: Asistencia = new Asistencia();\n  public escaneando = false;\n  public datosQR: string = '';\n  public usuario: Usuario;\n  constructor(\n        private activeroute: ActivatedRoute // Permite obtener los parámetros de la página login\n      , private router: Router // Permite navegar entre páginas\n      , private alertController: AlertController // Permite mostrar mensajes emergentes más complejos que Toast\n      , private animationController: AnimationController) { // Permite crear animaciones con  \n\n    this.usuario = new Usuario('', '', '', '', '', '',);\n\n    // Se llama a la ruta activa y se obtienen sus parámetros mediante una subscripcion\n    this.activeroute.queryParams.subscribe(params => { \n\n      const nav = this.router.getCurrentNavigation();\n      if (nav) {\n        // Si tiene datos extra, se rescatan y se asignan a una propiedad\n        if (nav.extras.state) {\n          this.usuario = nav.extras.state['usuario'];\n          \n          return;\n        }\n      }\n      // Si no vienen datos extra desde la página anterior, quiere decir que el usuario\n      // intentó entrar directamente a la página home sin pasar por el login,\n      // de modo que el sistema debe enviarlo al login para que inicie sesión.\n      this.router.navigate(['/login']);\n\n    });\n  }\n  public animateItem(elementRef: any) {\n    this.animationController\n      .create()\n      .addElement(elementRef)\n      .iterations(1)\n      .duration(600)\n      .fromTo('transform', 'translate(100%)', 'translate(0%)')\n      .play();\n  }\n\n\n  public ngOnInit(): void {\n  }\n\n  public ngAfterViewInit(): void {\n    if (this.itemTitulo) {\n      const animation = this.animationController\n        .create()\n        .addElement(this.itemTitulo.nativeElement)\n        .iterations(1)\n        .duration(3000)\n        .fromTo('transform', 'translate(0%)', 'translate(45%)')\n        .fromTo('opacity', 0.2, 1);\n\n      animation.play();\n    }\n  }\n\n\n  // Se va a solicitar el uso de la cámara, por medio de \"navigator.mediaDevices.getUserMedia\".\n  // La cámara es necesaria para poder capturar el Código QR.\n  // Luego se cofigurará:\n  //     this.video.nativeElement.setAttribute('playsinline', 'true');\n  // que permite que el video se reproduzca dentro del contexto de la página, en lugar de\n  // cambiar automáticamente al modo de pantalla completa en dispositivos iOS. \n  // Esto sirve para proporcionar una experiencia de usuario más fluida y evitar \n  // interrupciones al reproducir videos en el sitio web. Luego se iniciará el proceso de\n  // escaneo indicándolo por medio de la variable \"this.escaneando = true;\" y se podrá detener \n  // el escaneo por medio del botón de \"Detener\" que cambia a \"this.escaneando = false;\" o bien\n  // si la cámara detecta un código QR.\n\n  public async comenzarEscaneoQR() {\n    const mediaProvider: MediaProvider = await navigator.mediaDevices.getUserMedia({\n      video: {facingMode: 'environment'}\n    });\n    this.video.nativeElement.srcObject = mediaProvider;\n    this.video.nativeElement.setAttribute('playsinline', 'true');\n    this.video.nativeElement.play();\n    this.escaneando = true;\n    requestAnimationFrame(this.verificarVideo.bind(this));\n  }\n\n  // Las imágenes de la cámara se analizan muchas veces, hasta que logre encontrar un Código QR,\n  // por esta razón se usa la función del navegador \"requestAnimationFrame\", que permite realizar\n  // actualizaciones de la interfaz de usuario de manera eficiente y sincronizada con los \n  // refrescos de la pantalla. Entonces, en cada refresco de pantalla el programa realizará una\n  // pequeña pausa para analizar si el fotograma capturado es o no un Código QR, por medio de\n  // la función this.obtenerDatosQR().\n\n  async verificarVideo() {\n    if (this.video.nativeElement.readyState === this.video.nativeElement.HAVE_ENOUGH_DATA) {\n      if (this.obtenerDatosQR() || !this.escaneando) return;\n      requestAnimationFrame(this.verificarVideo.bind(this));\n    } else {\n      requestAnimationFrame(this.verificarVideo.bind(this));\n    }\n  }\n\n  // Si \"obtenerDatosQR\" encuentra un QR válido entonces se mostrarán los datos en pantalla\n  // y se devolverá true para detener el escaneo. En caso contrario, mientras no se detecte\n  // un QR, la función \"obtenerDatosQR\" devolverá false y el método \"verificarVideo\" se \n  // volverá a ejecutar nuevamente.\n  // Para analizar la imagen se usan los Elementos HTML: video y canvas. El TAG HTML \"video\"\n  // sirve para establecer un recuadro en la pantalla donde se visualiza el video de la \n  // cámara. Cada fotograma de la cámara es redibujado dentro del TAG HTML \"canvas\", \n  // de modo que es la imagen del canvas, la que analiza la biblioteca \"jsQR\". \n\n  public obtenerDatosQR(): boolean {\n    const w: number = this.video.nativeElement.videoWidth;\n    const h: number = this.video.nativeElement.videoHeight;\n    this.canvas.nativeElement.width = w;\n    this.canvas.nativeElement.height = h;\n    const context: CanvasRenderingContext2D = this.canvas.nativeElement.getContext('2d');\n    context.drawImage(this.video.nativeElement, 0, 0, w, h);\n    const img: ImageData = context.getImageData(0, 0, w, h);\n    let qrCode: QRCode | null = jsQR(img.data, w, h, { inversionAttempts: 'dontInvert' });\n    if (qrCode) {\n      if (qrCode.data !== '') {\n        this.escaneando = false;\n        this.mostrarDatosQROrdenados(qrCode.data);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public mostrarDatosQROrdenados(datosQR: string): void {\n    this.datosQR = datosQR;\n    \n    const objetoDatosQR = JSON.parse(datosQR);\n\n\n    \n    // ----------------------------------\n    // TAREA PARA COMPLETAR POR EL ALUMNO\n    // ----------------------------------\n    // 1) Ejecutar el setter de la clase Asistencia:\n    //     this.asistencia.setAsistencia(...parametros...)\n    //    de modo que los parámetros los tome del objeto datosQR,\n    //    por ejemplo: datosQR.nombreAsignatura contiene el valor \n    //    del nombre de la asignatura en la cual el alumno\n    //    debe quedar presente.\n    // 2) Hacer una interpolación entre las propiedades \n    //    de \"this.asistencia\" y la página HTML, de modo\n    //    que la página muestre de manera ordenada estos datos.\n  }\n\n  // Si la propiedad this.escaneando cambia a false, entonces la función\n  // \"verificarVideo\" deja de ejecutarse y se detiene el escaneo del QR.\n\n  public detenerEscaneoQR(): void {\n    this.escaneando = false;\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}